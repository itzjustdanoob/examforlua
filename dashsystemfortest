--[[
    ═══════════════════════════════════════════════════════════════
    COMBAT DASH SYSTEM
    ═══════════════════════════════════════════════════════════════
    THIS TIME IT SHOULD MATCH EVEERYTHING T-T
    A dash mechanics system featuring physics-based
    movement, real-time collision detection, visual effects, and
    health-based cancellation.
    
    Features:
    - Multi-directional dash mechanics (Front, Back, Left, Right)
    - Physics-based velocity with dynamic deceleration
    - Real-time hitbox detection with spatial queries
    - Procedural visual effects (trails, particles, shockwaves)
    - Health monitoring and damage-based cancellation
    - CFrame mathematics for positioning and rotation
    
]]

local DashModule = {} -- creates main module table to be returned

local TweenService = game:GetService("TweenService") -- gets TweenService for smooth animations
local Debris = game:GetService("Debris") -- gets Debris for auto-cleanup of temporary objects
local RunService = game:GetService("RunService") -- gets RunService for frame-by-frame updates
local Players = game:GetService("Players") -- gets Players service for player information
local Workspace = game:GetService("Workspace") -- gets Workspace where all 3D objects exist

local FRONT_DASH_VELOCITY = 120 -- initial velocity for forward dash in studs per second
local BACK_DASH_VELOCITY = 100 -- initial velocity for backward dash in studs per second
local SIDE_DASH_VELOCITY = 100 -- initial velocity for side dashes in studs per second
local FRONT_DECELERATION = 7 -- deceleration rate for front dash in studs per second squared
local BACK_DECELERATION = 7.5 -- deceleration rate for back dash in studs per second squared
local SIDE_DECELERATION = 7.5 -- deceleration rate for side dash in studs per second squared
local MIN_VELOCITY = 7 -- minimum velocity threshold before applying different deceleration
local CANCEL_WINDOW = 0.44 -- time window in seconds where damage cancels dash
local HITBOX_SIZE = Vector3.new(5.9, 6, 6.05) -- dimensions of collision hitbox in studs
local HITBOX_OFFSET = CFrame.new(0, 0, -3.5) -- offset position of hitbox from character center
local TRAIL_DURATION = 0.6 -- duration trails remain visible in seconds
local SMOKE_SPAWN_RATE = 0.075 -- time between smoke particle spawns in seconds
local DAMAGE_AMOUNT = 15 -- damage dealt to enemies hit by dash

local function createAttachment(parent, position)
    local attachment = Instance.new("Attachment") -- creates new Attachment instance
    attachment.Position = position -- sets attachment position relative to parent
    attachment.Parent = parent -- parents attachment to specified part
    return attachment -- returns the created attachment
end

local function createTrailEffect(limb, duration)
    local attach0 = createAttachment(limb, Vector3.new(0, 0.5, 0)) -- creates attachment at top of limb
    local attach1 = createAttachment(limb, Vector3.new(0, -0.5, 0)) -- creates attachment at bottom of limb
    
    local trail = Instance.new("Trail") -- creates Trail instance for motion trail
    trail.Attachment0 = attach0 -- connects trail to first attachment
    trail.Attachment1 = attach1 -- connects trail to second attachment
    trail.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255)) -- sets trail color to white
    trail.Transparency = NumberSequence.new({ -- defines transparency gradient
        NumberSequenceKeypoint.new(0, 0.5), -- starts at 50% transparent
        NumberSequenceKeypoint.new(1, 1) -- ends fully transparent
    })
    trail.Lifetime = 0.3 -- sets lifetime of each trail segment in seconds
    trail.MinLength = 0.1 -- minimum distance before trail appears in studs
    trail.FaceCamera = true -- makes trail face camera for better visibility
    trail.Parent = limb -- parents trail to limb part
    
    Debris:AddItem(attach0, duration) -- schedules first attachment for removal
    Debris:AddItem(attach1, duration) -- schedules second attachment for removal
    Debris:AddItem(trail, duration) -- schedules trail for removal
end

local function createHighlightEffect(character, duration)
    local highlight = Instance.new("Highlight") -- creates Highlight for character glow
    highlight.FillColor = Color3.fromRGB(255, 255, 255) -- sets fill to white color
    highlight.OutlineColor = Color3.fromRGB(0, 0, 0) -- sets outline to black color
    highlight.FillTransparency = 0 -- starts fully opaque
    highlight.OutlineTransparency = 0 -- outline starts fully opaque
    highlight.Parent = character -- parents to character model
    
    local tween = TweenService:Create(highlight, TweenInfo.new(duration), { -- creates fade tween
        FillTransparency = 1, -- fades fill to transparent
        OutlineTransparency = 1 -- fades outline to transparent
    })
    tween:Play() -- starts playing the tween
    Debris:AddItem(highlight, duration) -- schedules highlight for removal
end

local function createShockwave(rootPart)
    local ring = Instance.new("Part") -- creates Part for shockwave visual
    ring.Name = "Shockwave" -- sets descriptive name
    ring.Size = Vector3.new(1, 0.5, 1) -- sets initial small size
    ring.Material = Enum.Material.Neon -- uses Neon material for glow effect
    ring.Color = Color3.fromRGB(255, 255, 255) -- sets color to white
    ring.Transparency = 0.3 -- sets partially transparent
    ring.Anchored = true -- anchors in place
    ring.CanCollide = false -- disables collision
    ring.CFrame = rootPart.CFrame * CFrame.new(0, 0, 1) * CFrame.Angles(math.rad(90), 0, 0) -- positions in front and rotates horizontal
    ring.Parent = Workspace.Debris or Workspace -- parents to Debris folder
    
    local mesh = Instance.new("SpecialMesh") -- creates mesh for ring shape
    mesh.MeshType = Enum.MeshType.FileMesh -- uses file mesh type
    mesh.MeshId = "rbxassetid://3270017" -- loads ring mesh from catalog
    mesh.Scale = Vector3.new(1, 1, 1) -- sets initial scale
    mesh.Parent = ring -- parents mesh to ring part
    
    local expandTween = TweenService:Create(ring, TweenInfo.new(0.25), { -- creates expansion animation
        Size = Vector3.new(8, 0.75, 8), -- expands to large size
        Transparency = 1, -- fades to invisible
        CFrame = ring.CFrame * CFrame.new(0, 0, -1) -- moves backward during expansion
    })
    expandTween:Play() -- plays expansion animation
    Debris:AddItem(ring, 0.3) -- removes after animation completes
end

local function findGroundColor(position)
    local rayParams = RaycastParams.new() -- creates raycast parameters
    rayParams.FilterType = Enum.RaycastFilterType.Include -- uses whitelist filtering
    rayParams.FilterDescendantsInstances = {Workspace:FindFirstChild("Map") or Workspace} -- only detects Map
    
    local result = Workspace:Raycast(position, Vector3.new(0, -5, 0), rayParams) -- casts ray downward 5 studs
    
    if result then -- checks if ray hit ground
        return result.Instance.Color -- returns color of hit surface
    end
    return Color3.fromRGB(100, 100, 100) -- returns default gray if no hit
end

local function createGroundSmoke(position)
    local groundColor = findGroundColor(position) -- gets ground color at position
    
    local smokePart = Instance.new("Part") -- creates invisible part for particles
    smokePart.Size = Vector3.new(4, 0.1, 4) -- sets flat rectangular size
    smokePart.Transparency = 1 -- makes invisible
    smokePart.Anchored = true -- anchors in place
    smokePart.CanCollide = false -- disables collision
    smokePart.Position = position -- sets position at ground level
    smokePart.Parent = Workspace.Debris or Workspace -- parents to Debris
    
    local emitter = Instance.new("ParticleEmitter") -- creates particle emitter
    emitter.Color = ColorSequence.new(groundColor) -- matches ground color
    emitter.Size = NumberSequence.new({ -- defines size over lifetime
        NumberSequenceKeypoint.new(0, 0.5), -- starts small
        NumberSequenceKeypoint.new(0.5, 1.5), -- grows to peak
        NumberSequenceKeypoint.new(1, 0) -- shrinks to nothing
    })
    emitter.Transparency = NumberSequence.new({ -- defines transparency over lifetime
        NumberSequenceKeypoint.new(0, 0.5), -- starts semi-transparent
        NumberSequenceKeypoint.new(1, 1) -- fades to invisible
    })
    emitter.Lifetime = NumberRange.new(1, 1.5) -- particles live 1-1.5 seconds
    emitter.Rate = 0 -- no continuous emission
    emitter.Speed = NumberRange.new(5, 10) -- particles move 5-10 studs per second
    emitter.SpreadAngle = Vector2.new(30, 30) -- spreads in 30 degree cone
    emitter.Parent = smokePart -- parents emitter to smoke part
    
    emitter:Emit(20) -- emits burst of 20 particles
    Debris:AddItem(smokePart, 2) -- removes after 2 seconds
end

local function spawnRockDebris(cframe, direction, spread, size, lifetime)
    local rayParams = RaycastParams.new() -- creates raycast parameters
    rayParams.FilterType = Enum.RaycastFilterType.Include -- uses whitelist
    rayParams.FilterDescendantsInstances = {Workspace:FindFirstChild("Map") or Workspace} -- only detects Map
    
    for angle = 180, 360, 180 do -- loops for both sides (180 and 360 degrees)
        local sideCFrame = cframe * CFrame.Angles(0, math.rad(angle), 0) * CFrame.new(spread, 0, 0) -- calculates side position
        local rayResult = Workspace:Raycast(sideCFrame.Position, direction, rayParams) -- raycasts to find ground
        
        if rayResult then -- checks if ground found
            local rock = Instance.new("Part") -- creates rock part
            rock.Size = Vector3.new(size, size, size) -- sets cubic size
            rock.Material = rayResult.Instance.Material -- matches ground material
            rock.BrickColor = rayResult.Instance.BrickColor -- matches ground color
            rock.CFrame = CFrame.new(rayResult.Position) * CFrame.Angles( -- positions at hit point with random rotation
                math.rad(math.random(-360, 360)), -- random X rotation
                math.rad(math.random(-360, 360)), -- random Y rotation
                math.rad(math.random(-360, 360)) -- random Z rotation
            )
            rock.Anchored = true -- anchors in place
            rock.CanCollide = false -- disables collision
            rock.Parent = Workspace.Debris or Workspace -- parents to Debris
            
            task.delay(lifetime, function() -- schedules delayed function
                local sinkTween = TweenService:Create(rock, TweenInfo.new(0.5), { -- creates sinking animation
                    Position = rock.Position - Vector3.new(0, size, 0) -- moves down by its height
                })
                sinkTween:Play() -- plays sinking animation
                Debris:AddItem(rock, 0.5) -- removes after sinking
            end)
        end
    end
end

local function showDamageNumber(rootPart, damage)
    local offsetX = math.random(-4, 4) -- generates random horizontal offset
    
    local billboard = Instance.new("BillboardGui") -- creates billboard GUI for 3D text
    billboard.Size = UDim2.new(4, 0, 2, 0) -- sets size in studs
    billboard.StudsOffset = Vector3.new(offsetX, 2, 0) -- offsets above character
    billboard.AlwaysOnTop = true -- renders on top of everything
    billboard.Parent = Workspace.Debris or Workspace -- parents to Debris
    
    local textLabel = Instance.new("TextLabel") -- creates text label
    textLabel.Size = UDim2.new(1, 0, 1, 0) -- fills billboard
    textLabel.BackgroundTransparency = 1 -- makes background invisible
    textLabel.Text = "-" .. tostring(damage) -- sets text to damage value
    textLabel.TextColor3 = Color3.fromRGB(0, 0, 0) -- starts black
    textLabel.TextScaled = true -- scales text to fit
    textLabel.Font = Enum.Font.GothamBold -- uses bold font
    textLabel.Parent = billboard -- parents to billboard
    
    local stroke = Instance.new("UIStroke") -- creates text outline
    stroke.Thickness = 2 -- sets outline thickness
    stroke.Color = Color3.fromRGB(255, 255, 255) -- white outline
    stroke.Parent = textLabel -- parents to text
    
    local anchor = Instance.new("Part") -- creates anchor point
    anchor.Size = Vector3.new(0.1, 0.1, 0.1) -- tiny size
    anchor.Transparency = 1 -- invisible
    anchor.CanCollide = false -- no collision
    anchor.Anchored = false -- allows physics
    anchor.CFrame = rootPart.CFrame * CFrame.new(offsetX, 0, 0) -- positions near character
    anchor.Parent = Workspace.Debris or Workspace -- parents to Debris
    
    billboard.Adornee = anchor -- attaches billboard to anchor
    
    local upForce = Instance.new("BodyVelocity") -- creates upward force
    upForce.MaxForce = Vector3.new(0, 40000, 0) -- limits to Y axis
    upForce.Velocity = Vector3.new(0, 15, 0) -- moves up at 15 studs per second
    upForce.Parent = anchor -- parents to anchor
    
    local colorTween = TweenService:Create(textLabel, TweenInfo.new(0.16, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 1), { -- creates color flash
        TextColor3 = Color3.fromRGB(216, 31, 31) -- flashes to red
    })
    colorTween:Play() -- plays color animation
    
    Debris:AddItem(upForce, 0.08) -- removes force after brief moment
    Debris:AddItem(anchor, 0.5) -- removes anchor after half second
    Debris:AddItem(billboard, 0.5) -- removes billboard after half second
end

local function createDashHitbox(character, rootPart)
    local hitbox = Instance.new("Part") -- creates hitbox part
    hitbox.Name = "DashHitbox" -- sets name
    hitbox.Size = HITBOX_SIZE -- sets size from constant
    hitbox.Transparency = 1 -- makes invisible
    hitbox.CanCollide = false -- disables collision
    hitbox.Anchored = false -- allows welding
    hitbox.CFrame = rootPart.CFrame * HITBOX_OFFSET -- positions using offset
    hitbox.Parent = Workspace.Debris or Workspace -- parents to Debris
    
    local weld = Instance.new("WeldConstraint") -- creates weld
    weld.Part0 = hitbox -- connects to hitbox
    weld.Part1 = rootPart -- connects to character
    weld.Parent = hitbox -- parents to hitbox
    
    return hitbox -- returns created hitbox
end

local function detectHits(hitbox, character, onHitCallback)
    local hitTargets = {} -- initializes table to track hit enemies
    local overlapParams = OverlapParams.new() -- creates overlap parameters
    overlapParams.FilterType = Enum.RaycastFilterType.Exclude -- uses blacklist
    overlapParams.FilterDescendantsInstances = { -- sets exclusion list
        Workspace:FindFirstChild("Map") or Workspace, -- excludes map
        character, -- excludes own character
        Workspace.Debris or Workspace -- excludes debris
    }
    
    local connection = RunService.Heartbeat:Connect(function() -- connects to frame update
        if not hitbox or not hitbox.Parent then -- checks if hitbox destroyed
            connection:Disconnect() -- disconnects if destroyed
            return -- exits function
        end
        
        local parts = Workspace:GetPartsInPart(hitbox, overlapParams) -- gets overlapping parts
        
        for _, part in pairs(parts) do -- loops through each part
            local enemy = part.Parent -- gets parent model
            if enemy then -- checks if parent exists
                local humanoid = enemy:FindFirstChildWhichIsA("Humanoid") -- finds humanoid
                
                if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Dead and not table.find(hitTargets, enemy) then -- validates enemy
                    table.insert(hitTargets, enemy) -- adds to hit list
                    onHitCallback(enemy, humanoid) -- calls hit callback
                end
            end
        end
    end)
    
    return connection -- returns connection for cleanup
end

local function applyKnockback(enemyRoot, sourceRoot, force)
    local direction = (enemyRoot.Position - sourceRoot.Position).Unit -- calculates knockback direction
    local bodyVelocity = Instance.new("BodyVelocity") -- creates velocity constraint
    bodyVelocity.MaxForce = Vector3.new(20000, 0, 20000) -- limits to horizontal
    bodyVelocity.Velocity = direction * force -- applies force in direction
    bodyVelocity.Parent = enemyRoot -- parents to enemy
    Debris:AddItem(bodyVelocity, 0.2) -- removes after brief moment
end

local function createDamageHighlight(enemy, duration)
    local highlight = Instance.new("Highlight") -- creates highlight
    highlight.FillColor = Color3.fromRGB(255, 0, 4) -- sets red color
    highlight.OutlineColor = Color3.fromRGB(0, 0, 0) -- black outline
    highlight.FillTransparency = 0 -- starts opaque
    highlight.OutlineTransparency = 0 -- outline opaque
    highlight.Parent = enemy -- parents to enemy
    
    local fadeTween = TweenService:Create(highlight, TweenInfo.new(duration), { -- creates fade
        FillTransparency = 1, -- fades to transparent
        OutlineTransparency = 1 -- outline fades
    })
    fadeTween:Play() -- plays fade
    Debris:AddItem(highlight, duration) -- removes after duration
end

function DashModule.Dash(dashData)
    local character = dashData.Char -- extracts character from data
    local direction = dashData.Dir -- extracts direction
    local animation = dashData.Anim -- extracts animation
    local rootPart = character.HumanoidRootPart -- gets root part
    local humanoid = character:FindFirstChildWhichIsA("Humanoid") -- gets humanoid
    
    local isFrontDash = (direction == "Front") -- checks if forward dash
    local isBackDash = (direction == "Backward") -- checks if backward dash
    
    local initialVelocity = isFrontDash and FRONT_DASH_VELOCITY or BACK_DASH_VELOCITY -- selects velocity
    local deceleration = isFrontDash and FRONT_DECELERATION or BACK_DECELERATION -- selects deceleration
    
    if isBackDash then -- checks if backward dash
        animation:AdjustSpeed(1.2) -- speeds up animation
    end
    
    local initialHealth = humanoid.Health -- records starting health
    local startTime = os.clock() -- records start time
    local canceled = false -- initializes cancel flag
    
    local healthConnection = humanoid.HealthChanged:Connect(function(newHealth) -- monitors health changes
        if initialHealth > newHealth and (os.clock() - startTime) < CANCEL_WINDOW then -- checks for damage in window
            canceled = true -- sets cancel flag
        end
    end)
    
    createHighlightEffect(character, 0.75) -- creates character glow
    
    if isFrontDash then -- checks if forward dash
        createShockwave(rootPart) -- creates shockwave effect
        local rightArm = character:FindFirstChild("Right Arm") or character:FindFirstChild("RightHand") -- finds right limb
        if rightArm then createTrailEffect(rightArm, TRAIL_DURATION) end -- creates trail
        
        local hitbox = createDashHitbox(character, rootPart) -- creates hitbox
        local hitConnection = detectHits(hitbox, character, function(enemy, enemyHumanoid) -- starts hit detection
            enemyHumanoid:TakeDamage(DAMAGE_AMOUNT) -- deals damage
            showDamageNumber(enemy.HumanoidRootPart, DAMAGE_AMOUNT) -- shows damage
            applyKnockback(enemy.HumanoidRootPart, rootPart, 50) -- applies knockback
            createDamageHighlight(enemy, 0.5) -- creates hit flash
        end)
        
        Debris:AddItem(hitbox, 0.7) -- removes hitbox after duration
        task.delay(0.7, function() hitConnection:Disconnect() end) -- disconnects hit detection
    else -- backward dash
        local rightArm = character:FindFirstChild("Right Arm") or character:FindFirstChild("RightHand") -- finds right limb
        local leftArm = character:FindFirstChild("Left Arm") or character:FindFirstChild("LeftHand") -- finds left limb
        if rightArm then createTrailEffect(rightArm, 0.5) end -- creates right trail
        if leftArm then createTrailEffect(leftArm, 0.5) end -- creates left trail
    end
    
    local bodyVelocity = Instance.new("BodyVelocity") -- creates velocity constraint
    bodyVelocity.MaxForce = Vector3.new(30000, 0, 30000) -- limits to horizontal
    bodyVelocity.Parent = rootPart -- parents to character
    
    task.spawn(function() -- spawns VFX thread
        local vfxStart = os.clock() -- records VFX start time
        repeat -- starts VFX loop
            task.wait(SMOKE_SPAWN_RATE) -- waits between spawns
            if canceled then break end -- exits if canceled
            createGroundSmoke(rootPart.Position) -- creates smoke
            spawnRockDebris(rootPart.CFrame, rootPart.CFrame.UpVector * -5, 2, 0.75, 1.5) -- spawns rocks
        until (os.clock() - vfxStart) > 0.77 or humanoid.Health < initialHealth -- continues until duration or damage
    end)
    
    local velocity = initialVelocity -- initializes velocity
    local directionMultiplier = isFrontDash and 1 or -1 -- sets direction multiplier
    bodyVelocity.Velocity = rootPart.CFrame.LookVector * (velocity * directionMultiplier) -- sets initial velocity
    
    if isBackDash then -- checks if backward dash
        local phaseChanged = false -- initializes phase flag
        animation:GetMarkerReachedSignal("dashAgain"):Connect(function() -- listens for marker
            if not phaseChanged then -- checks if not changed yet
                velocity = 80 -- changes to second phase velocity
                phaseChanged = true -- sets flag
            end
        end)
    end
    
    repeat -- starts physics loop
        if canceled then -- checks if canceled
            velocity = 0 -- stops velocity
            break -- exits loop
        end
        
        if isFrontDash and velocity < MIN_VELOCITY then -- checks front dash slow threshold
            velocity = velocity - 1 -- slower deceleration
        else -- normal speed
            velocity = velocity - deceleration -- normal deceleration
        end
        
        task.wait(0.025) -- waits 25 milliseconds
        bodyVelocity.Velocity = rootPart.CFrame.LookVector * (velocity * directionMultiplier) -- updates velocity
    until velocity <= 0 or humanoid.Health < initialHealth -- continues until stopped or damaged
    
    bodyVelocity:Destroy() -- removes velocity constraint
    animation:Stop() -- stops animation
    healthConnection:Disconnect() -- disconnects health monitor
end

function DashModule.sideDash(dashData)
    local character = dashData.Char -- extracts character
    local direction = dashData.Dir -- extracts direction
    local animation = dashData.Anim -- extracts animation
    local rootPart = character.HumanoidRootPart -- gets root part
    local humanoid = character:FindFirstChildWhichIsA("Humanoid") -- gets humanoid
    
    local rightArm = character:FindFirstChild("Right Arm") or character:FindFirstChild("RightHand") -- finds right limb
    local leftArm = character:FindFirstChild("Left Arm") or character:FindFirstChild("LeftHand") -- finds left limb
    if rightArm then createTrailEffect(rightArm, 0.5) end -- creates right trail
    if leftArm then createTrailEffect(leftArm, 0.5) end -- creates left trail
    
    local initialHealth = humanoid.Health -- records health
    local startTime = os.clock() -- records time
    local canceled = false -- initializes flag
    
    local healthConnection = humanoid.HealthChanged:Connect(function(newHealth) -- monitors health
        if initialHealth > newHealth and (os.clock() - startTime) < CANCEL_WINDOW then -- checks damage
            canceled = true -- cancels dash
        end
    end)
    
    createHighlightEffect(character, 0.75) -- creates glow
    
    local bodyVelocity = Instance.new("BodyVelocity") -- creates velocity
    bodyVelocity.MaxForce = Vector3.new(30000, 0, 30000) -- limits horizontal
    bodyVelocity.Parent = rootPart -- parents to character
    
    local autoRotateRestore = animation.Stopped:Connect(function() -- listens for stop
        humanoid.AutoRotate = true -- restores rotation
    end)
    
    task.spawn(function() -- spawns VFX thread
        local vfxStart = os.clock() -- records start
        repeat -- starts loop
            task.wait(SMOKE_SPAWN_RATE) -- waits between spawns
            if canceled then break end -- exits if canceled
            createGroundSmoke(rootPart.Position) -- creates smoke
            spawnRockDebris(rootPart.CFrame, rootPart.CFrame.UpVector * -5, 2, 0.75, 1.5) -- spawns rocks
        until (os.clock() - vfxStart) > 0.3 or humanoid.Health < initialHealth -- continues until duration
    end)
    
    local velocity = SIDE_DASH_VELOCITY -- initializes velocity
    local dirMultiplier = (direction == "Left") and -1 or 1 -- calculates direction
    bodyVelocity.Velocity = rootPart.CFrame.RightVector * (velocity * dirMultiplier) -- sets velocity
    
    repeat -- starts physics loop
        if canceled then -- checks canceled
            velocity = 0 -- stops
            break -- exits
        end
        
        task.wait(0.025) -- waits frame
        velocity = velocity - SIDE_DECELERATION -- decelerates
        bodyVelocity.Velocity = rootPart.CFrame.RightVector * (velocity * dirMultiplier) -- updates velocity
    until velocity <= 0 or humanoid.Health < initialHealth -- continues until stopped
    
    bodyVelocity:Destroy() -- removes velocity
    animation:Stop() -- stops animation
    healthConnection:Disconnect() -- disconnects health
    autoRotateRestore:Disconnect() -- disconnects rotation restore
end

return DashModule -- returns module table
